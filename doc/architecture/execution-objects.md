# Execution objects

**Execution objects** allow clients and extensions to efficiently and securely exchange binary objects (files).

![Execution objects](/doc/images/arch-execution-objects.JPG)

### Object providers

**Object providers** are essentially modular, indirect file orchestrators that faciliate exchange of files between clients and extensions. They are uniquely named and indepdently versioned.

**Object providers** are primarily responsible for generating **[object accessors](#object-accessors)** which are used by clients and extensions to exchange files. They are also responsible for organizing and maintaining the underlying file storage structure. The execution API provides **object providers** with the original execution request allowing them to efficiently partition file storage across executions, extensions, and customers.

The [key concepts](#key-concepts) diagram above features the **az-blob/v1 object provider**. This object provider orchestrates exchange of files between clients and extensions using [Azure blob storage](https://azure.microsoft.com/en-us/services/storage/blobs/). 

The **object provider** that is used for any given execution is determined by the chosen **execution profile** and the **object providers** that the extension supports. This relationship creates the flexibility needed to use different **object providers** based on customer scenario.

**Object providers** can be registered [directly through the execution API](/src/draco/api/Execution.Api/Modules/Factories/ObjectAccessorProviderFactoryModule.cs) or [through the stand-alone execution agent](/src/draco/core/Agent/ExecutionAdapter.ConsoleHost/Modules/ObjectAccessorProviderFactoryModule.cs).

> **Best practice**: You should consider implementing a retention policy that archives or deletes **execution objects** after a predetermined amount of time. [Azure blob storage's lifecycle management feature](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-lifecycle-management-concepts) makes it easy to automate this.

> **Best practice**: Instead of forcing extensions to support specific **object providers**, consider creating an extension [sidecar process](https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar) that implements the needed **object providers** and stages files for extensions in a way that they can more easily access. For instance, if you're working with an extension that expects objects to be available at a specific file system path but you need to implement the **az-blobs/v1 object provider**, you could easily create a process that marshals files back and forth from Azure blob storage. This put the responsibility back on Draco to support different **object providers** while limiting changes to existing extensions.

> **Best practice**: To enable even looser coupling and frictionless, zero-downtime updates, Draco provides [a standardized mechanism for wrapping **object providers** in their own APIs](/src/draco/api/ObjectStorageProvider.Api) which can then be deployed independently of the execution API and/or execution console. This also makes it easier to create **object providers** in cases where C# is not the preferred programming language.

#### Implementation

Under the hood, **object providers** implement the [IInputObjectAccessorProvider](/src/draco/core/ObjectStorage/Interfaces/IInputObjectAccessorProvider.cs) and [IOutputObjectAccessorProvider](/src/draco/core/ObjectStorage/Interfaces/IOutputObjectAccessorProvider.cs) interfaces. If you're creating new object providers in C#, this is the recommended approach even if you're planning on wrapping the **object provider** within its own API as highlighted in the best practice above. Using a common interface gives you greater flexibility in how you deploy **object providers**.

### Object accessors

**Object accessors** are simple, digitally-signed JSON objects that contain all the information needed to allow clients and extensions to securely exchange files. They are both scope and time-limited. **Object accessors** are generated by **[object providers](#object-providers)**.

**Object accessors** typically contain different kinds of information based on the [**object providers**](#object-providers) that generated them. For example, the **az-blobs/v1 [object provider](#object-providers)** generates read-only and write-only [shared access signatures (SAS)](https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview) that allow clients and extensions to exchange files using simple HTTP GET (read-only) and PUT (write-only) requests.

Below is an example **object accessor** generated by the **az-blobs/v1 [object provider](#object-providers)**.

```json
{
  "url": "https://notarealstorageaccount.blob.core.windows.net/extensionobjects/c2afa23d-dac9-4159-8d5d-308b25ff34e5_7bb853a6-892c-4f5e-99f3-ad98e707ed93_598f9af9-f226-41b4-bd82-a2944cb1f1b1_3c8343ae-e1c7-40a3-8fe4-c60de3afbaee/input/original?sv=2019-02-02&sr=b&sig=zW5IB9yk8ynHXQ3Cl8JL0IYwRqhKmHr5boaSaLcLzUs%3D&spr=https&se=2020-01-29T02%3A01%3A05Z&sp=r",
  "urlSignature": "CwQqUSy5Qrx66SXV995FDSuX1wgFp0ccB8Ww5Qah1gF4BAy77haTs9s2G6z/8/vjZkrlxPP6IwgWGwBFcRvAVwVobukIBnP1K9HQ/ZoyvmuqYjV8to193QahpNwdPKUlw6+quKQtxuoLr+ShxNqC+3G7VhyW4yxgjjI9mOpNNjU=",
  "httpMethod": "GET",
  "accessMode": "ReadOnly",
  "expirationDateTimeUtc": "2020-01-29T02:01:05.3549743Z"
}
```

- Extension Hub’s unique, pluggable **object provider** model makes it easy to implement custom object storage – SMB, NFS, AWS S3, or any other storage provider.
- Like **execution models**, **object providers** are independently named and versioned.
- Out of the box, Extension Hub natively supports Azure blobs (**azblobs/v1**).
