# The Draco execution pipeline

At the heart of Draco lies a robust execution pipeline that enables the nearly unlimited flexibility in defining how, when, and where extensions are executed. The design of this pipeline attempts to strike a reasonable balance between complexity, flexibility, and reusability.

The Draco execution pipeline consists of a series of discrete, loosely-coupled components which are described in extensive detail in the following sections. Together, these components form a consistent and repeatable workflow that powers every extension execution. Understanding these components and how they work together is a critical first step in extending and customizing the core Draco platform to better fit your unique needs.

> **Note**: This document dives deep into the inner workings of the Draco execution pipeline. Most of this material is pretty advanced and, if you're using Draco as-is out-of-the-box, you probably won't need this level of depth. That being said, if you plan on extending the Draco platform or are simply curious about how things work "under the hood", the concepts outlined in this document are important to understand and will make your journey much easier.

## Architecture overview

![Execution pipeline overview](/doc/images/arch-exec-pipeline.JPG)

### Key components

| Color | Name | Description
| ----- | ---- | -----------
| ![#000000](https://placehold.it/32/000000/000000?text=+) | **Pipeline host process** | A pipeline host process is any process (typically packaged within a Docker container) hosting an execution pipeline. In the above diagram, the pipeline host processes are the [execution adapter API](/src/draco/api/ExecutionAdapter.Api), [execution API](/src/draco/api/Execution.Api), and [remote execution agent](/src/draco/core/Agent/ExecutionAdapter.ConsoleHost). Note that each pipeline host process hosts its own independent execution pipeline but all execution requests must originally enter the Draco platform through the [execution API](/src/draco/api/Execution.Api). Information on configuring the execution pipeline for each of these pipeline host processes can be [found below](#configuring-the-execution-pipeline).<br /><br />While these are the only pipeline host processes that Draco provides out-of-the-box, you can use the same [Draco core execution components](/src/draco/core/Core.Execution) to stand up an execution pipeline within any hosting environment that supports C#/.NET Standard 2.0.
| ![#333F50](https://placehold.it/32/333F50/333F50?text=+) | **Execution request router** | The execution request router's only responsibility is to take an [execution request](/src/draco/core/Core.Models/ExecutionRequest.cs) from the pipeline host process and route it to the appropriate execution processor. Typically, this routing is based on the [execution model](/doc/architecture/execution-models.md) defined in the request.<br /><br />All execution routers must implement the [IExecutionRequestRouter interface](/Interfaces/IExecutionRequestRouter.cs). Draco includes a [basic execution request router](/src/draco/core/Core.Execution/Routers/ExecutionRequestRouter.cs) that is suitable for most common use cases. 
| ![#2F528F](https://placehold.it/32/2F528F/2F528F?text=+) | **Execution processor** | The execution processor has two responsibilities – to hand off the execution request to an execution adapter and to report the execution status back to the [execution API](/src/draco/api/Execution.Api). Out-of-the-box, there are two types of execution processors – [remote](/src/draco/core/Core.Execution/Processors/AsyncExecutionProcessor.cs) and [local](/src/draco/core/Core.Execution/Processors/ExecutionProcessor.cs) – which are highlighted in the architectural diagram above. All execution processors must implement the [IExecutionProcessor interface](/src/draco/core/Core.Execution/Interfaces/IExecutionProcessor.cs).<br /><br />In the local scenario (in the case of the [execution API](/src/draco/api/Execution.Api) and the [execution adapter API](/src/draco/api/ExecutionAdapter.Api)), the execution status update is handed directly back to the execution request router in-process.<br /><br />In the [remote execution agent](/src/draco/core/Agent/ExecutionAdapter.ConsoleHost) model, we assume that the agent is running independently on-premises behind a corporate firewall allowing only TCP 443 outbound. In this case, the remote execution processor posts the execution status update directly back to the [execution API](/src/draco/api/Execution.Api) along with a unique, execution-scoped status update key that guarantees the authenticity of the original execution request. **The status update key is an important part of remote execution security and should be known only to Draco and the extension.**
| ![#C55A11](https://placehold.it/32/C55A11/C55A11?text=+) | **Execution adapter** | The execution adapter is an [execution model](/doc/architecture/execution-models.md)-specific component that is utlimately responsible for actually invoking the extension. The adapter handles both execution and validation operations and is responsible for handing input/output [object accessors](/doc/architecture/execution-objects.md#object-accessors) and exposing [extension services](/doc/architecture/extension-services.md) to the target extension per the [execution model](/doc/architecture/execution-models.md) specified in the [execution request](/src/draco/core/Core.Models/ExecutionRequest.cs). All execution adapters must implement the [IExecutionAdapter interface](/src/draco/core/Core.Execution/Interfaces/IExecutionAdapter.cs).<br /><br />Execution adapters generally fall into two categories – direct and proxy – both of which are highlighted in the diagram above.<br /><br />Direct execution adapters execute the extension directly. Out-of-the-box, Draco supports two execution models – `json-http/async/v1` and `json-http/sync/v1` – which expect target extensions to expose a very basic JSON-based REST API [described in more detail here](/doc/architecture/execution-models.md#example). These execution models are supported by [this direct execution adapter](/src/draco/core/Core.Execution/Adapters/JsonHttpExecutionAdapter.cs). Every execution pipeline, at some point, leverages a direct execution adapter.<br /><br />Proxy execution adapters pass execution requests from one pipeline host process to another. In the diagram above, the [execution API](/src/draco/api/Execution.Api) passes some execution requests to the [execution adapter API](/src/draco/api/ExecutionAdapter.Api) via [this proxy execution adapter](/src/draco/api/Api.Proxies/ProxyExecutionAdapter.cs).<br /><br />In the case of asynchronous, remote execution, execution adapters may queue execution requests for future processing. In the [remote execution agent](/src/draco/core/Agent/ExecutionAdapter.ConsoleHost) example shown in the diagram above, the [execution API](/src/draco/api/Execution.Api) stages these execution requests to an Azure service bus topic through [this proxy execution adapter](/src/draco/platforms/Azure/Azure.Execution/ServiceBusExecutionAdapter.cs).  
| ![#548235](https://placehold.it/32/548235/548235?text=+) | **Extension** | The extension itself. An extension is defined simply as *a uniquely identifiable, independently versioned, self-contained application feature*. 

## Configuring the execution pipeline

Execution pipeline configuration is accomplished through [service modules](/src/draco/core/Core.Hosting/Interfaces/IServiceModule.cs). Specific service modules involved in execution pipeline configuration are highlighted in the following sections.

### Configuring the execution API pipeline

All execution API service modules are configured in [Startup.cs](/src/draco/api/Execution.Api/Startup.cs).

- [CoreExecutionPipelineModule.cs](/src/draco/api/Api.Modules/CoreExecutionPipelineModule.cs) (part of the Api.Modules projects) contains most of the boilerplate binding you will need to get up and running including the default service provider, default execution request router, and execution processors needed to process asynchronous executions (through the remote execution agent in the diagram above) and the built-in `json-http/sync/v1` execution model. You'll need to register a new execution controller for each execution adapter that you add.
- [ExecutionProcessorFactoryModule.cs](/src/draco/api/Execution.Api/Modules/Factories/ExecutionProcessorFactoryModule.cs) binds [execution models](/doc/architecture/execution-models.md) to specific execution processors. By default, both the `json-http/async/v1` and `json-http/sync/v1` execution models are configured here. As you onboard new [execution models and adapters](/doc/architecture/execution-models.md), this is where you would register them with the execution API.
- Each execution adapter also needs to be registered. The best practice is to create and register a new module for each execution adapter that you register. The [JsonHttpExecutionAdapterModule.cs module](/src/draco/api/Api.Modules/JsonHttpExecutionAdapterModule.cs) demonstrates how to register the [JsonHttpExecutionAdapter.cs execution adapter](/src/draco/core/Core.Execution/Adapters/JsonHttpExecutionAdapter.cs).
- Platform-specific bindings should be contained within their own module. This approach makes it easy to re-platform your Draco environment if needed. Out-of-the-box, Azure-specific execution API bindings are registered in [AzureExecutionPipelineModule.cs](/src/draco/api/Execution.Api/Modules/Azure/AzureExecutionPipelineModule.cs). Note that the [IAsyncExecutionAdapter execution adapter interface](/src/draco/core/Core.Execution/Interfaces/IAsyncExecutionDispatcher.cs), needed to dispatch asynchronous execution requests to the remote execution agent highlighted in the diagram above, is bound to the [ServiceBusExecutionAdapter execution adapter](/src/draco/platforms/Azure/Azure.Execution/ServiceBusExecutionAdapter.cs).

### Configuring the execution adapter API pipeline

All execution adapter API service modules are configured in [Startup.cs](/src/draco/api/ExecutionAdapter.Api/Startup.cs). 

> Currently, all execution adapter API pipeline service modules are "stubbed out" for testing purposes. These can easily be replaced with production service modules as described in the [execution API configuration section](#configuring-the-execution-api-pipeline) above. We plan on providing execution adapter API-specific service module guidance in the near future.

### Configuring the remote execution agent pipeline

All remote execution agent service modules are configured in [Program.cs](/src/draco/core/Agent/ExecutionAdapter.ConsoleHost/Program.cs).

- [CoreExecutionPipelineModule.cs](/src/draco/api/Api.Modules/CoreExecutionPipelineModule.cs) (part of the Api.Modules projects) contains most of the boilerplate binding you will need to get up and running including the default service provider, default execution request router, and execution processors needed to process asynchronous executions (through the remote execution agent in the diagram above) and the built-in `json-http/sync/v1` execution model. You'll need to register a new execution controller for each execution adapter that you add to the remote execution agent.
- [ExecutionProcessorFactoryModule.cs](r/src/draco/core/Agent/ExecutionAdapter.ConsoleHost/Modules/ExecutionProcessorFactoryModule.cs) binds [execution models](/doc/architecture/execution-models.md) to specific execution processors. By default, the `json-http/async/v1` execution adapter is registered here. As you onboard new [execution models and adapters](/doc/architecture/execution-models.md), this is where you would register them with the remote execution agent.
- Each execution adapter also needs to be registered. The best practice is to create and register a new module for each execution adapter that you register. The [JsonHttpExecutionAdapterModule.cs module](/src/draco/api/Api.Modules/JsonHttpExecutionAdapterModule.cs) demonstrates how to register the [JsonHttpExecutionAdapter.cs execution adapter](/src/draco/core/Core.Execution/Adapters/JsonHttpExecutionAdapter.cs).
- Platform-specific bindings should be contained within their own module. This approach makes it easy to re-platform your Draco environment if needed. Out-of-the-box, Azure-specific execution API bindings are registered in [AzureExecutionPipelineModule.cs](/src/draco/core/Agent/ExecutionAdapter.ConsoleHost/Modules/Azure/AzureExecutionPipelineModule.cs). Note that the [IExecutionRequestSubscriber interface](/src/draco/core/Core.Execution/Interfaces/IExecutionRequestSubscriber.cs), needed to subscribe to execution requests published to service bus in the diagram above, is bound to the [ServiceBusExecutionRequestSubscriber request subscriber](/src/draco/platforms/Azure/Azure.Execution/ServiceBusExecutionRequestSubscriber.cs).


